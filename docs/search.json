[
  {
    "objectID": "rctd-weights.html",
    "href": "rctd-weights.html",
    "title": "Interpreting RCTD weights",
    "section": "",
    "text": "In this document, we run spacexr’s RCTD algorithm on simple synthetic data to infer that the weights matrix should be interpreted as the proportion of RNA molecules originating from each cell type in each spot, rather than the fraction of cells assigned to each cell type.\n\nlibrary(spacexr)\n\n\nCreate mock cell types\nAs the first step, we create two mock cell types with corresponding “gene” expression. RCTD requires at least 10 differentially expressed genes. I choose to have five genes specific to each of two cell types A and B, and five constitutively expressed genes that have equal counts across each cell. Crucially, we choose cell type B to have a higher total expression than cell type A, because its markers are more highly expressed.\n\ntypeA &lt;- c(\n  \"a1\" = 1,\n  \"a2\" = 2,\n  \"a3\" = 3,\n  \"a4\" = 4,\n  \"a5\" = 5,\n  \"b1\" = 0,\n  \"b2\" = 0,\n  \"b3\" = 0,\n  \"b4\" = 0,\n  \"b5\" = 0,\n  \"c1\" = 1,\n  \"c2\" = 2,\n  \"c3\" = 3,\n  \"c4\" = 4,\n  \"c5\" = 5\n)\ntypeB &lt;- c(\n  \"a1\" = 0,\n  \"a2\" = 0,\n  \"a3\" = 0,\n  \"a4\" = 0,\n  \"a5\" = 0,\n  \"b1\" = 10,\n  \"b2\" = 20,\n  \"b3\" = 30,\n  \"b4\" = 40,\n  \"b5\" = 50,\n  \"c1\" = 1,\n  \"c2\" = 2,\n  \"c3\" = 3,\n  \"c4\" = 4,\n  \"c5\" = 5\n)\n\n\n\nCreate RCTD objects\nFirst we create the RCTD reference. At some point down the line, RCTD errors with only one cell per cell type in the reference, so the reference contains two identical cells of both cell types.\n\nreference_counts &lt;- data.frame(\n  cell1 = typeA, cell2 = typeA, cell3 = typeB, cell4 = typeB\n) |&gt;\n  as.matrix()\nreference_types &lt;- factor(\n  c(\n    \"cell1\" = \"typeA\", \"cell2\" = \"typeA\",\n    \"cell3\" = \"typeB\", \"cell4\" = \"typeB\"\n  ),\n  levels = c(\"typeA\", \"typeB\")\n)\nreference_nUMI &lt;- colSums(reference_counts)\nreference &lt;- spacexr::Reference(\n  reference_counts,\n  reference_types,\n  reference_nUMI,\n  min_UMI = 10\n)\n\nNext, we mock up some spatial data. We let spot 1 contain 1 cell of type A and 1 cell of type B. Spot 2 contains 1 cell A and 3 cells of type B, spot 3 contains 3 cells of type A and one of type B, and spot 4 contains 3 cells of each type.\n\nspatial_coords &lt;- tibble::tribble(\n  ~spot, ~x, ~y,\n  \"spot1\", 0, 0,\n  \"spot2\", 1, 0,\n  \"spot3\", 0, 1,\n  \"spot4\", 1, 1\n) |&gt;\n  tibble::column_to_rownames(\"spot\")\nspatial_counts &lt;- data.frame(\n  spot1 = typeA + typeB,\n  spot2 = typeA + 3 * typeB,\n  spot3 = 3 * typeA + typeB,\n  spot4 = 3 * typeA + 3 * typeB\n) |&gt;\n  as.matrix()\nnUMI &lt;- colSums(spatial_counts)\npuck &lt;- SpatialRNA(spatial_coords, spatial_counts, nUMI)\n\nFinally, we create the RCTD object itself from the mock reference and spatial data. We have to provide a few parameters to enable the small size of the mock data.\n\nmyRCTD &lt;- create.RCTD(\n  puck, reference,\n  max_cores = 1,\n  counts_MIN = 1,\n  CELL_MIN_INSTANCE = 1\n  )\n\nBegin: process_cell_type_info\n\n\nprocess_cell_type_info: number of cells in reference: 4\n\n\nprocess_cell_type_info: number of genes in reference: 15\n\n\n\ntypeA typeB \n    2     2 \n\n\nEnd: process_cell_type_info\n\n\ncreate.RCTD: getting regression differentially expressed genes: \n\n\nget_de_genes: typeA found DE genes: 10\n\n\nget_de_genes: typeB found DE genes: 5\n\n\nget_de_genes: total DE genes: 15\n\n\ncreate.RCTD: getting platform effect normalization differentially expressed genes: \n\n\nget_de_genes: typeA found DE genes: 10\n\n\nget_de_genes: typeB found DE genes: 5\n\n\nget_de_genes: total DE genes: 15\n\n\nNote that it finds 10 marker genes for typeA, which means that the constitutively expressed genes are included. Indeed, their relative abundance is higher in cell type A than in cell type B.\n\n\nRun RCTD to find cell type fractions\nNow we finally run the RCTD algorithm to get cell type proportions. I always use full mode on my own data so that is what I do here. For this mock data using doublet mode would be appropriate (it has the same interpretation).\n\nmyRCTD &lt;- run.RCTD(myRCTD, doublet_mode = \"full\")\n\nfitBulk: decomposing bulk\n\n\nchooseSigma: using initial Q_mat with sigma =  1\n\n\nLikelihood value: 113.745139064746\n\n\nSigma value:  0.84\n\n\nLikelihood value: 109.153842621005\n\n\nSigma value:  0.69\n\n\nLikelihood value: 104.184989239904\n\n\nSigma value:  0.61\n\n\nLikelihood value: 101.205842339197\n\n\nSigma value:  0.53\n\n\nLikelihood value: 97.9501354713587\n\n\nSigma value:  0.45\n\n\nLikelihood value: 94.3725160205627\n\n\nSigma value:  0.37\n\n\nLikelihood value: 90.4213192913567\n\n\nSigma value:  0.29\n\n\nLikelihood value: 86.0445136616334\n\n\nSigma value:  0.21\n\n\n\n\nInterpretation\nThe moment of truth:\n\nmyRCTD@results$weights\n\n4 x 2 sparse Matrix of class \"dgCMatrix\"\n           typeA     typeB\nspot1 0.15105219 0.8358883\nspot2 0.05609608 0.9349949\nspot3 0.34829858 0.6393917\nspot4 0.15169237 0.8395874\n\n\nClearly, these weights do not correspond to the fraction of cells in a spot that are of each cell type. If so, the matrix would have been equal to\n\nfractions &lt;- tibble::tribble(\n  ~spot, ~typeA, ~typeB,\n  \"spot1\", 0.5, 0.5,\n  \"spot2\", 0.25, 0.75,\n  \"spot3\", 0.75, 0.25,\n  \"spot4\", 0.5, 0.5\n) |&gt;\n  tibble::column_to_rownames(\"spot\") |&gt;\n  as.matrix()\nfractions\n\n      typeA typeB\nspot1  0.50  0.50\nspot2  0.25  0.75\nspot3  0.75  0.25\nspot4  0.50  0.50\n\n\nInstead, the weights represent the proportion of RNA molecules in a spot that originated in cells of each type.\n\nmolsA &lt;- sum(typeA)\nmolsB &lt;- sum(typeB)\nproportions &lt;- matrix(\n  c(\n    c(molsA, molsB)/(molsA + molsB),\n    c(molsA, 3*molsB)/(molsA + 3*molsB), \n    c(3*molsA, molsB)/(3*molsA + molsB),\n    c(3*molsA, 3*molsB)/(3*molsA + 3*molsB)\n  ),\n  ncol = 2,\n  byrow = TRUE,\n  dimnames = list(\n    c(\"spot1\", \"spot2\", \"spot3\", \"spot4\"),\n    c(\"typeA\", \"typeB\")\n  )\n)\nproportions\n\n           typeA     typeB\nspot1 0.15384615 0.8461538\nspot2 0.05714286 0.9428571\nspot3 0.35294118 0.6470588\nspot4 0.15384615 0.8461538\n\n\nAs a final note, the weights were very close to being normalised already, but for completion’s sake:\n\nnormalize_weights(myRCTD@results$weights)\n\n4 x 2 Matrix of class \"dgeMatrix\"\n           typeA     typeB\nspot1 0.15305096 0.8469490\nspot2 0.05660033 0.9433997\nspot3 0.35263948 0.6473605\nspot4 0.15302681 0.8469732\n\n\n\nsessionInfo()\n\nR version 4.3.2 (2023-10-31 ucrt)\nPlatform: x86_64-w64-mingw32/x64 (64-bit)\nRunning under: Windows 10 x64 (build 19045)\n\nMatrix products: default\n\n\nlocale:\n[1] LC_COLLATE=English_United Kingdom.utf8 \n[2] LC_CTYPE=English_United Kingdom.utf8   \n[3] LC_MONETARY=English_United Kingdom.utf8\n[4] LC_NUMERIC=C                           \n[5] LC_TIME=English_United Kingdom.utf8    \n\ntime zone: Europe/London\ntzcode source: internal\n\nattached base packages:\n[1] stats     graphics  grDevices datasets  utils     methods   base     \n\nother attached packages:\n[1] spacexr_2.2.1\n\nloaded via a namespace (and not attached):\n [1] vctrs_0.6.5       doParallel_1.0.17 cli_3.6.2         knitr_1.45       \n [5] rlang_1.1.3       xfun_0.41         renv_1.0.3        jsonlite_1.8.8   \n [9] glue_1.7.0        htmltools_0.5.7   fansi_1.0.6       rmarkdown_2.25   \n[13] quadprog_1.5-8    grid_4.3.2        evaluate_0.23     tibble_3.2.1     \n[17] fastmap_1.1.1     yaml_2.3.8        foreach_1.5.2     lifecycle_1.0.4  \n[21] compiler_4.3.2    codetools_0.2-19  pkgconfig_2.0.3   lattice_0.21-9   \n[25] digest_0.6.34     utf8_1.2.4        pillar_1.9.0      parallel_4.3.2   \n[29] magrittr_2.0.3    Matrix_1.6-1.1    tools_4.3.2       iterators_1.0.14"
  }
]